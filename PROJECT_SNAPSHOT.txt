===== PROJECT TREE =====

├── src
│   ├── Markdown.Application
│   │   ├── ReadModels
│   │   │   ├── WorkspaceEntry.cs
│   │   ├── Services
│   │   │   ├── IWorkspaceExplorer.cs
│   │   ├── Markdown.Application.csproj
│   ├── Markdown.Core
│   │   ├── Markdown.Core.csproj
│   ├── Markdown.Domain
│   │   ├── Entities
│   │   │   ├── Document.cs
│   │   │   ├── Workspace.cs
│   │   ├── Interfaces
│   │   │   ├── IDocumentRepository.cs
│   │   │   ├── IWorkspaceRepository.cs
│   │   ├── Primitives
│   │   │   ├── AggregateRoot.cs
│   │   │   ├── Entity.cs
│   │   │   ├── Result.cs
│   │   ├── ValueObjects
│   │   │   ├── DocumentId.cs
│   │   │   ├── FilePath.cs
│   │   │   ├── MarkdownContent.cs
│   │   │   ├── WorkspaceId.cs
│   │   ├── GlobalUsings.cs
│   │   ├── Markdown.Domain.csproj
│   ├── Markdown.Infrastructure
│   │   ├── FileSystem
│   │   │   ├── FileDocumentRepository.cs
│   │   │   ├── FileWorkspaceRepository.cs
│   │   │   ├── WorkspaceExplorer.cs
│   │   ├── GlobalUsings.cs
│   │   ├── Markdown.Infrastructure.csproj
├── tests
│   ├── Markdown.Application.Tests
│   │   ├── Markdown.Application.Tests.csproj
│   ├── Markdown.Core.Tests
│   │   ├── Markdown.Core.Tests.csproj
│   ├── Markdown.Domain.Tests
│   │   ├── Markdown.Domain.Tests.csproj
│   ├── Markdown.Infrastructure.Tests
│   │   ├── Markdown.Infrastructure.Tests.csproj


===== FILE CONTENTS =====

--------------------------------------------------
FILE: .\src\Markdown.Application\Markdown.Application.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <ItemGroup>
    <ProjectReference Include="..\Markdown.Core\Markdown.Core.csproj" />
    <ProjectReference Include="..\Markdown.Domain\Markdown.Domain.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <RootNamespace>Markdown.Application</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>
</Project>

--------------------------------------------------
FILE: .\src\Markdown.Application\ReadModels\WorkspaceEntry.cs
--------------------------------------------------

namespace Markdown.Application.ReadModels;

public sealed record WorkspaceEntry(
    string Path,
    FileEntryType Type,
    string Name,
    long Size,
    DateTime ModifiedAt,
    bool IsMarkdownFile
)
{
    public static WorkspaceEntry FromFileInfo(FileInfo fileInfo)
    {
        ArgumentNullException.ThrowIfNull(fileInfo);

        bool isMarkdown = fileInfo.Extension.Equals(".md", StringComparison.OrdinalIgnoreCase)
            || fileInfo.Extension.Equals(".markdown", StringComparison.OrdinalIgnoreCase);

        return new WorkspaceEntry(
            Path: fileInfo.FullName,
            Type: FileEntryType.File,
            Name: fileInfo.Name,
            Size: fileInfo.Length,
            ModifiedAt: fileInfo.LastWriteTimeUtc,
            IsMarkdownFile: isMarkdown
        );
    }

    public static WorkspaceEntry FromDirectoryInfo(DirectoryInfo dirInfo)
    {
        ArgumentNullException.ThrowIfNull(dirInfo);

        return new WorkspaceEntry(
            Path: dirInfo.FullName,
            Type: FileEntryType.Folder,
            Name: dirInfo.Name,
            Size: 0,
            ModifiedAt: dirInfo.LastWriteTimeUtc,
            IsMarkdownFile: false
        );
    }
}

public enum FileEntryType
{
    File,
    Folder
}

--------------------------------------------------
FILE: .\src\Markdown.Application\Services\IWorkspaceExplorer.cs
--------------------------------------------------

using Markdown.Application.ReadModels;

namespace Markdown.Application.Services;

public interface IWorkspaceExplorer
{
    Task<IEnumerable<WorkspaceEntry>> GetEntriesAsync(
        string rootPath,
        CancellationToken cancellationToken = default);

    Task<IEnumerable<WorkspaceEntry>> GetEntriesAsync(
        string rootPath,
        int maxDepth,
        CancellationToken cancellationToken = default);

    Task<IEnumerable<WorkspaceEntry>> GetMarkdownFilesAsync(
        string rootPath,
        CancellationToken cancellationToken = default);
}

--------------------------------------------------
FILE: .\src\Markdown.Core\Markdown.Core.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Core</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>
</Project>

--------------------------------------------------
FILE: .\src\Markdown.Domain\Entities\Document.cs
--------------------------------------------------

namespace Markdown.Domain.Entities;

public sealed class Document : AggregateRoot<DocumentId>
{
    public FilePath Path { get; private set; }
    public MarkdownContent Content { get; private set; }

    public DateTime LastModifiedUtc { get; private set; }

    public Document(
        DocumentId id,
        FilePath path,
        MarkdownContent content,
        DateTime lastModifiedUtc)
    {
        Id = id;
        Path = path;
        Content = content;
        LastModifiedUtc = lastModifiedUtc;
    }

    public Result UpdateContent(MarkdownContent newContent, DateTime utcNow)
    {
        if (newContent == Content)
        {
            return Results.Success();
        }

        Content = newContent;
        LastModifiedUtc = utcNow;
        return Results.Success();
    }

    public Result Move(FilePath newPath)
    {
        Path = newPath;
        return Results.Success();
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\Entities\Workspace.cs
--------------------------------------------------

namespace Markdown.Domain.Entities;

public sealed class Workspace : AggregateRoot<WorkspaceId>
{
    private readonly List<Document> _documents = [];

    public FilePath RootPath { get; }

    public IReadOnlyCollection<Document> Documents => _documents.AsReadOnly();

    public Workspace(WorkspaceId id, FilePath rootPath)
    {
        Id = id;
        RootPath = rootPath;
    }

    public Result AddDocument(Document document)
    {
        if (_documents.Any(d => d.Id == document.Id || d.Path == document.Path))
        {
            return Results.Failure("Document already exists.");
        }

        _documents.Add(document);
        return Results.Success();
    }

    public Document? FindDocument(DocumentId id)
    {
        return _documents.FirstOrDefault(d => d.Id == id);
    }

    public Result RemoveDocument(DocumentId documentId)
    {
        Document? doc = FindDocument(documentId);
        if (doc is null)
        {
            return Results.Failure("Document not found.");
        }

        _ = _documents.Remove(doc);
        return Results.Success();
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\GlobalUsings.cs
--------------------------------------------------

global using Markdown.Domain.Entities;
global using Markdown.Domain.Primitives;
global using Markdown.Domain.ValueObjects;

--------------------------------------------------
FILE: .\src\Markdown.Domain\Interfaces\IDocumentRepository.cs
--------------------------------------------------

namespace Markdown.Domain.Interfaces;

public interface IDocumentRepository
{
    Task<Result<Document?>> GetByIdAsync(DocumentId id, CancellationToken ct);
    Task<Result> SaveAsync(Document document, CancellationToken ct);
    Task<Result> DeleteAsync(DocumentId id, CancellationToken ct);
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\Interfaces\IWorkspaceRepository.cs
--------------------------------------------------

namespace Markdown.Domain.Interfaces;

public interface IWorkspaceRepository
{
    Task<Result<Workspace?>> GetByIdAsync(WorkspaceId id, CancellationToken ct);
    Task<Result> SaveAsync(Workspace workspace, CancellationToken ct);
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\Markdown.Domain.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Domain</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>
</Project>

--------------------------------------------------
FILE: .\src\Markdown.Domain\Primitives\AggregateRoot.cs
--------------------------------------------------

namespace Markdown.Domain.Primitives;

public abstract class AggregateRoot<TId> : Entity<TId> where TId : notnull
{
    protected AggregateRoot() { }

    protected AggregateRoot(TId id) : base(id) { }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\Primitives\Entity.cs
--------------------------------------------------

namespace Markdown.Domain.Primitives;

public abstract class Entity<TId> : IEquatable<Entity<TId>> where TId : notnull
{
    public TId Id { get; protected init; } = default!;

    protected Entity() { }

    protected Entity(TId id)
    {
        Id = id;
    }

    public bool Equals(Entity<TId>? other)
    {
        return other is not null && Id.Equals(other.Id);
    }

    public override bool Equals(object? obj)
    {
        return obj is Entity<TId> entity && Equals(entity);
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    public static bool operator ==(Entity<TId>? left, Entity<TId>? right)
    {
        return left?.Equals(right) ?? (right is null);
    }

    public static bool operator !=(Entity<TId>? left, Entity<TId>? right)
    {
        return !(left == right);
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\Primitives\Result.cs
--------------------------------------------------

namespace Markdown.Domain.Primitives;

public static class Results
{
    public static Result Success()
    {
        return Result.CreateSuccess();
    }

    public static Result Failure(string error)
    {
        return Result.CreateFailure(error);
    }

    public static Result<T> Success<T>(T value)
    {
        return Result<T>.CreateSuccess(value);
    }

    public static Result<T> Failure<T>(string error)
    {
        return Result<T>.CreateFailure(error);
    }
}

public class Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public string? Error { get; }

    protected Result(bool isSuccess, string? error)
    {
        if (isSuccess && error is not null)
        {
            throw new InvalidOperationException("Successful result cannot have an error.");
        }

        if (!isSuccess && string.IsNullOrWhiteSpace(error))
        {
            throw new ArgumentException("Failure result must have an error message.", nameof(error));
        }

        IsSuccess = isSuccess;
        Error = error;
    }

    internal static Result CreateSuccess()
    {
        return new(true, null);
    }

    internal static Result CreateFailure(string error)
    {
        return new(false, error);
    }
}

public sealed class Result<T> : Result
{
    public T Value { get; }

    private Result(bool isSuccess, T value, string? error) : base(isSuccess, error)
    {
        Value = value;
    }

    internal static Result<T> CreateSuccess(T value)
    {
        return new(true, value, null);
    }

    internal static new Result<T> CreateFailure(string error)
    {
        return new(false, default!, error);
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\ValueObjects\DocumentId.cs
--------------------------------------------------

namespace Markdown.Domain.ValueObjects;

public readonly record struct DocumentId(Guid Value)
{
    public static DocumentId New()
    {
        return new(Guid.NewGuid());
    }

    public override string ToString()
    {
        return Value.ToString();
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\ValueObjects\FilePath.cs
--------------------------------------------------

namespace Markdown.Domain.ValueObjects;

public sealed record FilePath
{
    public string Value { get; }

    public FilePath(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException("File path cannot be empty.", nameof(value));
        }

        Value = value;
    }

    public override string ToString()
    {
        return Value;
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\ValueObjects\MarkdownContent.cs
--------------------------------------------------

namespace Markdown.Domain.ValueObjects;

public sealed record MarkdownContent
{
    public string Value { get; }

    public MarkdownContent(string value)
    {
        Value = value ?? throw new ArgumentNullException(nameof(value));
    }

    public bool IsEmpty
        => string.IsNullOrEmpty(Value);

    public override string ToString()
    {
        return Value;
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Domain\ValueObjects\WorkspaceId.cs
--------------------------------------------------

namespace Markdown.Domain.ValueObjects;

public readonly record struct WorkspaceId(Guid Value)
{
    public static WorkspaceId New()
    {
        return new(Guid.NewGuid());
    }

    public override string ToString()
    {
        return Value.ToString();
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Infrastructure\FileSystem\FileDocumentRepository.cs
--------------------------------------------------

using Markdown.Domain.Interfaces;

namespace Markdown.Infrastructure.FileSystem;

public sealed class FileDocumentRepository : IDocumentRepository
{
    public Task<Result<Document?>> GetByIdAsync(DocumentId id, CancellationToken ct)
    {
        return Task.FromResult(Results.Success<Document?>(null));
    }

    public async Task<Result> SaveAsync(Document document, CancellationToken ct)
    {
        ArgumentNullException.ThrowIfNull(document);

        try
        {
            string path = document.Path.Value;
            _ = Directory.CreateDirectory(Path.GetDirectoryName(path)!);

            await File.WriteAllTextAsync(path, document.Content.Value, ct).ConfigureAwait(false);

            return Results.Success();
        }
        catch (Exception ex)
        {
            return Results.Failure($"Failed to save document: {ex.Message}");
        }
    }

    public Task<Result> DeleteAsync(DocumentId id, CancellationToken ct)
    {
        return Task.FromResult(Results.Failure("Delete is not supported yet."));
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Infrastructure\FileSystem\FileWorkspaceRepository.cs
--------------------------------------------------

using Markdown.Domain.Interfaces;

namespace Markdown.Infrastructure.FileSystem;

public sealed class FileWorkspaceRepository : IWorkspaceRepository
{
    public Task<Result<Workspace?>> GetByIdAsync(WorkspaceId id, CancellationToken ct)
    {
        return Task.FromResult(Results.Success<Workspace?>(null));
    }

    public Task<Result> SaveAsync(Workspace workspace, CancellationToken ct)
    {
        return Task.FromResult(Results.Success());
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Infrastructure\FileSystem\WorkspaceExplorer.cs
--------------------------------------------------

namespace Markdown.Infrastructure.FileSystem;

public sealed class WorkspaceExplorer : IWorkspaceExplorer
{
    public async Task<IEnumerable<WorkspaceEntry>> GetEntriesAsync(
        string rootPath,
        CancellationToken cancellationToken = default
    )
    {
        return await GetEntriesAsync(rootPath, maxDepth: int.MaxValue, cancellationToken).ConfigureAwait(false);
    }

    public async Task<IEnumerable<WorkspaceEntry>> GetEntriesAsync(
        string rootPath,
        int maxDepth,
        CancellationToken cancellationToken = default
    )
    {
        if (!Directory.Exists(rootPath))
        {
            return [];
        }

        List<WorkspaceEntry> result = [];

        await Task.Run(
            () =>
            {
                Traverse(new DirectoryInfo(rootPath), depth: 0);
            },
            cancellationToken
        ).ConfigureAwait(false);

        return result;

        void Traverse(DirectoryInfo dir, int depth)
        {
            if (depth > maxDepth || cancellationToken.IsCancellationRequested)
            {
                return;
            }

            foreach (DirectoryInfo directory in dir.GetDirectories())
            {
                result.Add(WorkspaceEntry.FromDirectoryInfo(directory));
                Traverse(directory, depth + 1);
            }

            foreach (FileInfo file in dir.GetFiles())
            {
                result.Add(WorkspaceEntry.FromFileInfo(file));
            }
        }
    }

    public async Task<IEnumerable<WorkspaceEntry>> GetMarkdownFilesAsync(
    string rootPath,
    CancellationToken cancellationToken = default
    )
    {
        IEnumerable<WorkspaceEntry> entries = await GetEntriesAsync(rootPath, maxDepth: int.MaxValue, cancellationToken).ConfigureAwait(false);

        return entries.Where(e => e.IsMarkdownFile);
    }
}

--------------------------------------------------
FILE: .\src\Markdown.Infrastructure\GlobalUsings.cs
--------------------------------------------------

global using Markdown.Application.ReadModels;
global using Markdown.Application.Services;
global using Markdown.Domain.Entities;
global using Markdown.Domain.Primitives;
global using Markdown.Domain.ValueObjects;

--------------------------------------------------
FILE: .\src\Markdown.Infrastructure\Markdown.Infrastructure.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <ItemGroup>
    <ProjectReference Include="..\Markdown.Application\Markdown.Application.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <RootNamespace>Markdown.Infrastructure</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>
</Project>

--------------------------------------------------
FILE: .\tests\Markdown.Application.Tests\Markdown.Application.Tests.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Application.Tests</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.collector" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Moq" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\Markdown.Application\Markdown.Application.csproj" />
    <ProjectReference Include="..\..\src\Markdown.Core\Markdown.Core.csproj" />
    <ProjectReference Include="..\..\src\Markdown.Domain\Markdown.Domain.csproj" />
  </ItemGroup>
</Project>

--------------------------------------------------
FILE: .\tests\Markdown.Core.Tests\Markdown.Core.Tests.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Core.Tests</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.collector" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Moq" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\Markdown.Core\Markdown.Core.csproj" />
  </ItemGroup>
</Project>

--------------------------------------------------
FILE: .\tests\Markdown.Domain.Tests\Markdown.Domain.Tests.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Domain.Tests</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.collector" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Moq" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\Markdown.Domain\Markdown.Domain.csproj" />
  </ItemGroup>
</Project>

--------------------------------------------------
FILE: .\tests\Markdown.Infrastructure.Tests\Markdown.Infrastructure.Tests.csproj
--------------------------------------------------

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <RootNamespace>Markdown.Infrastrucure.Tests</RootNamespace>
    <TargetFramework>net10.0</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="coverlet.collector" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Moq" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\Markdown.Infrastructure\Markdown.Infrastructure.csproj" />
    <ProjectReference Include="..\..\src\Markdown.Domain\Markdown.Domain.csproj" />
  </ItemGroup>
</Project>
